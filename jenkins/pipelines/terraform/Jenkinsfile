pipeline {
  agent any

  parameters {
    booleanParam(name: 'DESTROY', defaultValue: false, description: 'Rulează terraform destroy în loc de apply')
    booleanParam(name: 'AUTO_APPROVE', defaultValue: true, description: 'Aplică automat fără confirmare manuală')
  }

  environment {
    TF_DIR = "${WORKSPACE}/terraform"
    ANSIBLE_DIR = "${WORKSPACE}/ansible"
    TF_IN_AUTOMATION = "true"
    TF_INPUT = "false"

    AWS_ACCESS_KEY_ID     = credentials('aws-access-key')
    AWS_SECRET_ACCESS_KEY = credentials('aws-secret-key')

    OS_AUTH_URL                      = credentials('os-auth-url')
    OS_REGION_NAME                   = credentials('os-region-name')
    OS_APPLICATION_CREDENTIAL_ID     = credentials('os-application-cred-id')
    OS_APPLICATION_CREDENTIAL_SECRET = credentials('os-application-cred-secret')
    OS_AUTH_TYPE                     = "v3applicationcredential"
    OS_IDENTITY_API_VERSION          = "3"
    OS_INTERFACE                     = "public"
  }

  stages {

    stage('Checkout') {
      steps {
        echo "Preluăm codul din GitHub..."
        checkout scm
      }
    }

    stage('Terraform Init') {
      steps {
        dir("${TF_DIR}") {
          sh '''
            terraform init -input=false
          '''
        }
      }
    }

    stage('Terraform Validate & Plan') {
      when {
        expression { return !params.DESTROY }
      }
      steps {
        dir("${TF_DIR}") {
          sh '''
            terraform fmt -check -recursive
            terraform validate
            terraform plan -out=tfplan
            terraform show -no-color tfplan > plan.txt
          '''
        }
        archiveArtifacts artifacts: 'terraform/plan.txt', fingerprint: true
      }
    }

    stage('Confirmare manuală') {
      when {
        allOf {
          expression { return !params.AUTO_APPROVE }
          expression { return !params.DESTROY }
        }
      }
      steps {
        script {
          def confirm = input(
            message: "Aplicăm modificările Terraform?",
            ok: "Aplică",
            parameters: [
              choice(name: 'CONFIRM', choices: ['Da', 'Nu'], description: 'Confirmă acțiunea')
            ]
          )
          if (confirm != 'Da') {
            error "Aplicarea a fost anulată de utilizator."
          }
        }
      }
    }

    stage('Terraform Apply / Destroy') {
      steps {
        dir("${TF_DIR}") {
          sh '''
            if [ "${DESTROY}" = "true" ]; then
              echo "Rulăm terraform destroy..."
              terraform destroy -auto-approve
            else
              echo "Rulăm terraform apply..."
              if [ -f tfplan ]; then
                terraform apply -auto-approve tfplan
              else
                terraform apply -auto-approve
              fi
            fi
          '''
        }
      }
    }

    stage('Verificare Inventory Ansible') {
      when { expression { return !params.DESTROY } }
      steps {
        dir("${ANSIBLE_DIR}") {
          sh '''
            echo "Verificam daca inventarul Ansible a fost generat..."
            if [ ! -f inventory.ini ]; then
              echo "Fisierul inventory.ini nu exista!"
              exit 1
            fi

            echo "Inventory gasit:"
            cat inventory.ini
            echo ""
            echo "Verificam conectivitatea SSH catre toate serverele..."

            RETRIES=10
            DELAY=15
            COUNT=1

            while [ $COUNT -le $RETRIES ]; do
              echo "Incercarea $COUNT din $RETRIES..."
              
              ansible -i inventory.ini all -m ping -o
              RESULT=$?

              if [ $RESULT -eq 0 ]; then
                echo "Toate serverele raspund la ping!"
                break
              else
                echo "Unele servere nu raspund. Asteptam $DELAY secunde si reincercam..."
                sleep $DELAY
              fi
              COUNT=$((COUNT + 1))
            done

            if [ $RESULT -ne 0 ]; then
              echo "Serverele nu au raspuns nici dupa $RETRIES incercari."
              exit 1
            fi
          '''
        }
      }
    }


    stage('Verificare Master în Inventory') {
      when { expression { return !params.DESTROY } }
      steps {
        script {
          def inventoryFile = "${ANSIBLE_DIR}/inventory.ini"
          echo "Verificăm dacă există cel puțin un master în ${inventoryFile}..."

          if (!fileExists(inventoryFile)) {
            echo "Fișierul inventory.ini nu există — sar etapele Ansible."
            env.HAS_MASTER = 'false'
            return
          }

          def inventory = readFile(inventoryFile)
          def matcher = (inventory =~ /\[master\]([\s\S]*?)(\n\[|$)/)
          def masterSection = matcher ? matcher[0][1].trim() : ""

          if (!masterSection || !masterSection.contains("ansible_host")) {
            echo "Niciun master detectat în inventory.ini — sar etapele Ansible."
            env.HAS_MASTER = 'false'
          } else {
            echo "Master(i) detectați:\n${masterSection}"
            env.HAS_MASTER = 'true'
          }
        }
      }
    }


    stage('Ansible: Update pachete') {
      when {
        allOf {
          expression { return !params.DESTROY }
          expression { env.HAS_MASTER == 'true' }
        }
      }
      steps {
        dir("${ANSIBLE_DIR}") {
          sh '''
            echo "Rulăm update.yml pe toate serverele..."
            ansible-playbook update.yml
          '''
        }
      }
    }

    stage('Ansible: Configurare Load Balancer') {
      when {
        allOf {
          expression { return !params.DESTROY }
          expression { env.HAS_MASTER == 'true' }
        }
      }
      steps {
        dir("${ANSIBLE_DIR}") {
          sh '''
            echo "Configurăm NGINX Load Balancer..."
            ansible-playbook config-lb.yml
          '''
        }
      }
    }

    stage('Ansible: Instalare K3s Cluster') {
      when {
        allOf {
          expression { return !params.DESTROY }
          expression { env.HAS_MASTER == 'true' }
        }
      }
      steps {
        dir("${ANSIBLE_DIR}") {
          sh '''
            echo "Instalăm clusterul K3s..."
            ansible-playbook cluster-k3s.yml
          '''
        }
      }
    }

    stage('Ansible: Deploy Monitoring in K3s') {
      when {
        allOf {
          expression { return !params.DESTROY }
          expression { env.HAS_MASTER == 'true' }
        }
      }
      steps {
        dir("${ANSIBLE_DIR}") {
          sh '''
            ansible-playbook deploy-monitoring.yml
          '''
        }
      }
    }
  }

  post {
    success {
      echo "Pipeline complet Terraform + Ansible rulat cu succes!"
    }
    failure {
      echo "Eroare în rularea pipeline-ului Terraform/Ansible."
    }
    always {
      cleanWs()
    }
  }
}
